- There are four different types of data integrity:
* Entity integrity States that each entity (a record in a database) should be uniquely
identifiable. In a database, this is achieved by using a primary key column. A primary
key uniquely identifies each row of data. It can be generated by the database or by
your application.
* Domain integrity Refers to the validity of the data that an entity contains. This can
be about the type of data and the possible values that are allowed (a valid postal code,
a number within a certain range, or a default value, for example).
* Referential integrity The relationship that entities have with each other, such as the
relationship between an order and a customer.
* User-defined integrity Comprises specific business rules that you need to enforce.
A business rule for a web shop might involve a new customer who is not allowed to
place an order above a certain dollar amount.

- Parse/Convert
* The difference between Parse/TryParse and
Convert is that Convert enables null values. It doesn’t throw an ArgumentNullException; instead,
it returns the default value for the supplied type
* A difference between Convert and the Parse methods is that Parse takes a string only as
input, while Convert can also take other base types as input

-Xml/Json
* You can create an XSD file for this schema by using the XML Schema Definition Tool (Xsd.exe) that is a part of Visual Studio. This tool can generate XML Schema files or C# classes.
The following line will generate an XSD file for the person.xml file:
Xsd.exe person.xml


-------- rever 3.2
- Asymetric/symmetric
* Try to remember the differences between symmetric and asymmetric algorithms. A symmetric
algorithm uses one key; an asymmetric algorithm uses two: a key pair that consists
of both a public and a private key.

- hasing
* Hashing is the process of taking a large set of data and mapping it to a smaller data set of fixed length
* This technique is used by the Hashtable and Dictionary classes in the .NET Framework.
Both use the hash code to store and access items. Hashtable is nongeneric collection; Dictionary
is a generic collection.

- Certificates
* If you open a developer command prompt as administrator, you can run the following command to generate a testing certificate:
makecert testCert.cer
This command generates a file called testCert.cer that you can use as a certificate. You first need to install this certificate on your computer to be able to use it. After installation, it’s stored in a certificate store. The following line creates a certificate and installs it in a custom certificate store named testCertStore:
makecert -n "CN=WouterDeKort" -sr currentuser -ss testCertStore

- Access permissions
* Declarative means that you use attributes to apply security information to your code.
Listing 3-25 shows an example of asking for the permission to read all local files by using the
FileIOPermissionAttribute.
*You can also do this in an imperative way, which means that you explicitly ask for the permission
in the code. Listing 3-26 shows how you can create a new instance of FileIOPermission
and demand certain rights.

- Securing string data 
* Decrypt method                 || Clear memory method
SecureStringToBSTR               ||ZeroFreeBSTR
SecureStringToCoTaskMemAnsi      || ZeroFreeCoTaskMemAnsi
SecureStringToCoTaskMemUnicode   || ZeroFreeCoTaskMemUnicode
SecureStringToGlobalAllocAnsi    || ZeroFreeGlobalAllocAnsi
SecureStringToGlobalAllocUnicode || ZeroFreeGlobalAllocUnicode

- Assembly
* The CLR supports two different types of assemblies: strong-named assemblies and regular
assemblies
*Signing an assembly can be done both at the command line and by using Visual Studio.
The first step you have to take is to generate a key pair. A key pair is usually a file with an .snk
extension that contains your public/private key information.
When using the developer command prompt, you can run the following command to
generate a new key pair file:
sn -k myKey.snk
*Deploying an assembly in the GAC can be done in two ways:
■■
For production scenarios, use a specific installation program that has access to the GAC such as the Windows Installer 2.0.
■■
In development scenarios, use a tool called the Global Assembly Cache tool (Gacutil.exe).
You can view the content of your GAC by running the following command from a developer command prompt:
gacutil -l
This returns a list of all the assemblies that are installed in the GAC.
Installing an assembly in the GAC can be done with the following command:
gacutil –i [assembly name]
You can also remove an assembly from the GAC:
gacutil –u [assembly name]
 
 - Versioning assemblies
 * Each assembly has a version number that has the following format:
{Major Version}.{Minor Version}.{Build Number}.{Revision} AssemblyVersion("1.0.0.0")]
*The Major Version is manually incremented for each major release. A major release
should contain many new features or breaking changes.
* The Minor Version is incremented for minor releases that introduce only some small
changes to existing features.
* The Build Number is automatically incremented for each build by the build server. This
way, each build has a unique identification number that can be used to track it.
* The Revision is used for patches to the production environment.
 
- WinMD
*There are a couple of restrictions on your Windows Runtime component that you need to be aware of:
■■
The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.
■■
Public classes and interfaces can contain methods, properties and events. A public class or interface cannot do the following, however:
■■
Be generic
■■
Implement an interface that is not a Windows Runtime interface
■■
Derive from types that are not inside the Windows Runtime
■■
Public classes must be sealed.
■■
Public structures can have only public fields as members, which must be value types or strings.
■■
All public types must have a root namespace that matches the assembly name and does not start with Windows.


- Directives 
* Another preprocessor directive is #undef, which can be used to remove the definition of a symbol. This can be used in a situation where you want to debug a piece of code that’s normally included only in a release build. You can then use the #undef directive to remove the debug symbol.

- Trace 
■
Critical This is the most severe option. It should be used sparingly and only for very serious and irrecoverable errors.
■■
Error This enum member has a slightly lower priority than Critical, but it still indicates that something is wrong in the application. It should typically be used to flag a problem that has been handled or recovered from.
■■
Warning This value indicates something unusual has occurred that may be worth investigating further. For example, you notice that a certain operation suddenly takes longer to process than normal or you flag a warning that the server is getting low on memory.
■■
Information This value indicates that the process is executing correctly, but there is some interesting information to include in the tracing output file. It may be information that a user has logged onto a system or that something has been added to the database.
■■
Verbose This is the loosest of all the severity related values in the enum. It should be used for information that is not indicating anything wrong with the application and is likely to appear in vast quantities. For example, when instrumenting all methods in a type to trace their beginning and ending, it is typical to use the verbose event type.
■■
Stop, Start, Suspend, Resume, Transfer These event types are not indications of severity, but mark the trace event as relating to the logical flow of the application. They are known as activity event types and mark a logical operation’s starting or stopping, or transferring control to another logical operation.

TraceListeners in the .NET Framework
Name                       || Output
ConsoleTraceListener       || Standard output or error stream
DelimitedListTraceListener || TextWriter
EventLogTraceListener      || EventLog
EventSchemaTraceListener   || XML-encoded, schema-compliant log file
TextWriterTraceListener    || TextWriter
XmlWriterTraceListener     || XML-encoded data to a TextWriter or stream.


-- profile tools
*■
CPU sampling This is the most lightweight option. It has little effect on the application. You use it for an initial search for your performance problems.
■■
Instrumentation This method injects code into your compiled file that captures timing information for each function that is called. With instrumentation, you can find problems that have to do with input/output (I/O) or you can closely examine a particular method.
■■
.NET memory allocation This method interrupts your program each time the application allocates a new object or when the object is collected by the garbage collector to give you a good idea of how memory is being used in your program.
■■
Resource contention data This method can be used in multithreaded applications to find out why methods have to wait for each other before they can access a shared resource.

More Info VISUAL STUDIO PROFILER

